/*! @asymmetrik/ngx-leaflet - 2.5.2 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. + */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("leaflet")):"function"==typeof define&&define.amd?define(["exports","@angular/core","leaflet"],t):t(e.ngxLeaflet={},e.ng.core,e.L)}(this,function(e,t,r){"use strict";var n=/** @class */function(){function e(e){this.DEFAULT_ZOOM=1,this.DEFAULT_CENTER=r.latLng(38.907192,-77.036871),this.DEFAULT_FPZ_OPTIONS={},this.fitBoundsOptions=this.DEFAULT_FPZ_OPTIONS,this.panOptions=this.DEFAULT_FPZ_OPTIONS,this.zoomOptions=this.DEFAULT_FPZ_OPTIONS,this.zoomPanOptions=this.DEFAULT_FPZ_OPTIONS,
// Default configuration
this.options={},
// Configure callback function for the map
this.mapReady=new t.EventEmitter,this.element=e}/**
     * Resize the map to fit it's parent container
     */
/**
     * Manage a delayed resize of the component
     */
/**
     * Set the view (center/zoom) all at once
     * @param center The new center
     * @param zoom The new zoom level
     */
/**
     * Set the map zoom level
     * @param zoom the new zoom level for the map
     */
/**
     * Set the center of the map
     * @param center the center point
     */
/**
     * Fit the map to the bounds
     * @param center the center point
     */
/** @nocollapse */
return e.prototype.ngOnInit=function(){
// Create the map with some reasonable defaults
this.map=r.map(this.element.nativeElement,this.options),
// Only setView if there is a center/zoom
null!=this.center&&null!=this.zoom&&this.setView(this.center,this.zoom),
// Set up all the initial settings
null!=this.fitBounds&&this.setFitBounds(this.fitBounds),this.doResize(),
// Fire map ready event
this.mapReady.emit(this.map)},e.prototype.ngOnChanges=function(e){/*
         * The following code is to address an issue with our (basic) implementation of
         * zooming and panning. From our testing, it seems that a pan operation followed
         * by a zoom operation in the same thread will interfere with eachother. The zoom
         * operation interrupts/cancels the pan, resulting in a final center point that is
         * inaccurate. The solution seems to be to either separate them with a timeout or
          * to collapse them into a setView call.
         */
// Zooming and Panning
e.zoom&&e.center&&null!=this.zoom&&null!=this.center?this.setView(e.center.currentValue,e.zoom.currentValue):e.zoom?this.setZoom(e.zoom.currentValue):e.center&&this.setCenter(e.center.currentValue),
// Fit bounds
e.fitBounds&&this.setFitBounds(e.fitBounds.currentValue)},e.prototype.getMap=function(){return this.map},e.prototype.onResize=function(){this.delayResize()},e.prototype.doResize=function(){
// Invalidate the map size to trigger it to update itself
this.map.invalidateSize({})},e.prototype.delayResize=function(){null!=this.resizeTimer&&clearTimeout(this.resizeTimer),this.resizeTimer=setTimeout(this.doResize.bind(this),200)},e.prototype.setView=function(e,t){this.map&&null!=e&&null!=t&&this.map.setView(e,t,this.zoomPanOptions)},e.prototype.setZoom=function(e){this.map&&null!=e&&this.map.setZoom(e,this.zoomOptions)},e.prototype.setCenter=function(e){this.map&&null!=e&&this.map.panTo(e,this.panOptions)},e.prototype.setFitBounds=function(e){this.map&&null!=e&&this.map.fitBounds(e,this.fitBoundsOptions)},e.decorators=[{type:t.Directive,args:[{selector:"[leaflet]"}]}],e.ctorParameters=function(){return[{type:t.ElementRef}]},e.propDecorators={fitBoundsOptions:[{type:t.Input,args:["leafletFitBoundsOptions"]}],panOptions:[{type:t.Input,args:["leafletPanOptions"]}],zoomOptions:[{type:t.Input,args:["leafletZoomOptions"]}],zoomPanOptions:[{type:t.Input,args:["leafletZoomPanOptions"]}],options:[{type:t.Input,args:["leafletOptions"]}],mapReady:[{type:t.Output,args:["leafletMapReady"]}],zoom:[{type:t.Input,args:["leafletZoom"]}],center:[{type:t.Input,args:["leafletCenter"]}],fitBounds:[{type:t.Input,args:["leafletFitBounds"]}],onResize:[{type:t.HostListener,args:["window:resize",[]]}]},e}(),o=/** @class */function(){function e(e){this.leafletDirective=e}return e.prototype.init=function(){},e.prototype.getMap=function(){return this.leafletDirective.getMap()},e}(),i=/** @class */function(){function e(e){this.leafletDirective=new o(e)}/** @nocollapse */
return e.prototype.ngOnInit=function(){
// Init the map
this.leafletDirective.init()},e.prototype.ngOnDestroy=function(){this.layer.remove()},e.prototype.ngOnChanges=function(e){if(e.layer){
// Update the layer
var t=e.layer.previousValue,r=e.layer.currentValue;null!=t&&t.remove(),null!=r&&this.leafletDirective.getMap().addLayer(r)}},e.decorators=[{type:t.Directive,args:[{selector:"[leafletLayer]"}]}],e.ctorParameters=function(){return[{type:n}]},e.propDecorators={layer:[{type:t.Input,args:["leafletLayer"]}]},e}(),s=/** @class */function(){function e(e,t){this.differs=t,this.leafletDirective=new o(e),this.layersDiffer=this.differs.find([]).create()}/**
     * Update the state of the layers.
     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.
     * This is important because it allows us to react to changes to the contents of the array as well
     * as changes to the actual array instance.
     */
/** @nocollapse */
return Object.defineProperty(e.prototype,"layers",{get:function(){return this.layersValue},
// Set/get the layers
set:function(e){this.layersValue=e,
// Now that we have a differ, do an immediate layer update
this.updateLayers()},enumerable:!0,configurable:!0}),e.prototype.ngDoCheck=function(){this.updateLayers()},e.prototype.ngOnInit=function(){
// Init the map
this.leafletDirective.init(),
// Update layers once the map is ready
this.updateLayers()},e.prototype.ngOnDestroy=function(){this.layers=[]},e.prototype.updateLayers=function(){var e=this.leafletDirective.getMap();if(null!=e&&null!=this.layersDiffer){var t=this.layersDiffer.diff(this.layersValue);null!=t&&(t.forEachRemovedItem(function(t){e.removeLayer(t.item)}),t.forEachAddedItem(function(t){e.addLayer(t.item)}))}},e.decorators=[{type:t.Directive,args:[{selector:"[leafletLayers]"}]}],e.ctorParameters=function(){return[{type:n},{type:t.IterableDiffers}]},e.propDecorators={layers:[{type:t.Input,args:["leafletLayers"]}]},e}(),a=/** @class */function(){function e(){this.layersRemoved=0,this.layersChanged=0,this.layersAdded=0}return e.prototype.changed=function(){return!(0===this.layersRemoved&&0===this.layersChanged&&0===this.layersAdded)},e}(),l=/** @class */function(){function e(){}return e.prototype.getLayersControl=function(){return this.layersControl},e.prototype.init=function(e,t){var n=e.baseLayers||{},o=e.overlays||{};return this.layersControl=r.control.layers(n,o,t),this.layersControl},e.prototype.applyBaseLayerChanges=function(e){var t=new a;return null!=this.layersControl&&(t=this.applyChanges(e,this.layersControl.addBaseLayer)),t},e.prototype.applyOverlayChanges=function(e){var t=new a;return null!=this.layersControl&&(t=this.applyChanges(e,this.layersControl.addOverlay)),t},e.prototype.applyChanges=function(e,t){var r=this,n=new a;return null!=e&&(e.forEachChangedItem(function(e){r.layersControl.removeLayer(e.previousValue),t.call(r.layersControl,e.currentValue,e.key),n.layersChanged++}),e.forEachRemovedItem(function(e){r.layersControl.removeLayer(e.previousValue),n.layersRemoved++}),e.forEachAddedItem(function(e){t.call(r.layersControl,e.currentValue,e.key),n.layersAdded++})),n},e}(),u=/** @class */function(){return function(){this.baseLayers={},this.overlays={}}}(),y=/** @class */function(){function e(e,t){this.differs=t,this.leafletDirective=new o(e),this.controlLayers=new l,
// Generate differs
this.baseLayersDiffer=this.differs.find({}).create(),this.overlaysDiffer=this.differs.find({}).create()}/** @nocollapse */
return Object.defineProperty(e.prototype,"layersControlConfig",{get:function(){return this.layersControlConfigValue},set:function(e){
// Validation/init stuff
null==e&&(e=new u),null==e.baseLayers&&(e.baseLayers={}),null==e.overlays&&(e.overlays={}),
// Store the value
this.layersControlConfigValue=e,
// Update the map
this.updateLayers()},enumerable:!0,configurable:!0}),e.prototype.ngOnInit=function(){
// Init the map
this.leafletDirective.init(),
// Set up all the initial settings
this.controlLayers.init({},this.layersControlOptions).addTo(this.leafletDirective.getMap()),this.updateLayers()},e.prototype.ngOnDestroy=function(){this.layersControlConfig={baseLayers:{},overlays:{}},this.controlLayers.getLayersControl().remove()},e.prototype.ngDoCheck=function(){this.updateLayers()},e.prototype.updateLayers=function(){var e=this.leafletDirective.getMap(),t=this.controlLayers.getLayersControl();if(null!=e&&null!=t){
// Run the baselayers differ
if(null!=this.baseLayersDiffer&&null!=this.layersControlConfigValue.baseLayers){r=this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);this.controlLayers.applyBaseLayerChanges(r)}
// Run the overlays differ
if(null!=this.overlaysDiffer&&null!=this.layersControlConfigValue.overlays){var r=this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);this.controlLayers.applyOverlayChanges(r)}}},e.decorators=[{type:t.Directive,args:[{selector:"[leafletLayersControl]"}]}],e.ctorParameters=function(){return[{type:n},{type:t.KeyValueDiffers}]},e.propDecorators={layersControlConfig:[{type:t.Input,args:["leafletLayersControl"]}],layersControlOptions:[{type:t.Input,args:["leafletLayersControlOptions"]}]},e}(),p=/** @class */function(){function e(){}return e.mapToArray=function(e){var t=[];for(var r in e)e.hasOwnProperty(r)&&t.push(e[r]);return t},e}(),f=/** @class */function(){function e(e,t){this.differs=t,this.leafletDirective=new o(e),this.controlLayers=new l,this.baseLayersDiffer=this.differs.find({}).create()}/**
     * Check the current base layer and change it to the new one if necessary
     */
/** @nocollapse */
return Object.defineProperty(e.prototype,"baseLayers",{get:function(){return this.baseLayersValue},
// Set/get baseLayers
set:function(e){this.baseLayersValue=e,this.updateBaseLayers()},enumerable:!0,configurable:!0}),e.prototype.ngOnDestroy=function(){this.baseLayers={},this.controlLayers.getLayersControl().remove()},e.prototype.ngOnInit=function(){
// Init the map
this.leafletDirective.init(),
// Initially configure the controlLayers
this.controlLayers.init({},this.layersControlOptions).addTo(this.leafletDirective.getMap()),this.updateBaseLayers()},e.prototype.ngDoCheck=function(){this.updateBaseLayers()},e.prototype.updateBaseLayers=function(){var e=this.leafletDirective.getMap(),t=this.controlLayers.getLayersControl();if(null!=e&&null!=t&&null!=this.baseLayersDiffer){var r=this.baseLayersDiffer.diff(this.baseLayersValue);this.controlLayers.applyBaseLayerChanges(r).changed()&&this.syncBaseLayer()}},e.prototype.syncBaseLayer=function(){var e,t=this.leafletDirective.getMap(),r=p.mapToArray(this.baseLayers);
// Search all the layers in the map to see if we can find them in the baselayer array
t.eachLayer(function(t){e=r.find(function(e){return t===e})}),
// Did we find the layer?
null!=e?
// Yes - set the baselayer to the one we found
this.baseLayer=e:
// No - set the baselayer to the first in the array and add it to the map
r.length>0&&(this.baseLayer=r[0],this.baseLayer.addTo(t))},e.decorators=[{type:t.Directive,args:[{selector:"[leafletBaseLayers]"}]}],e.ctorParameters=function(){return[{type:n},{type:t.KeyValueDiffers}]},e.propDecorators={baseLayers:[{type:t.Input,args:["leafletBaseLayers"]}],layersControlOptions:[{type:t.Input,args:["leafletLayersControlOptions"]}]},e}(),c=/** @class */function(){function e(){}/** @nocollapse */
return e.forRoot=function(){return{ngModule:e,providers:[]}},e.decorators=[{type:t.NgModule,args:[{exports:[n,i,s,y,f],declarations:[n,i,s,y,f]}]}],e.ctorParameters=function(){return[]},e}(),h=/** @class */function(){function e(e,t,r){this.type=e,this.url=t,this.options=r}/**
     * Creates a TileLayer from the provided definition. This is a convenience function
     * to help with generating layers from objects.
     *
     * @param layerDef The layer to create
     * @returns {TileLayer} The TileLayer that has been created
     */
/**
     * Creates a TileLayer for each key in the incoming map. This is a convenience function
     * for generating an associative array of layers from an associative array of objects
     *
     * @param layerDefs A map of key to tile layer definition
     * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer
     */
/**
     * Create a Tile Layer from the current state of this object
     *
     * @returns {TileLayer} A new TileLayer
     */
return e.createTileLayer=function(e){var t;switch(e.type){case"xyz":t=r.tileLayer(e.url,e.options);break;case"wms":default:t=r.tileLayer.wms(e.url,e.options)}return t},e.createTileLayers=function(t){var r={};for(var n in t)t.hasOwnProperty(n)&&(r[n]=e.createTileLayer(t[n]));return r},e.prototype.createTileLayer=function(){return e.createTileLayer(this)},e}();e.LeafletModule=c,e.LeafletDirective=n,e.LeafletDirectiveWrapper=o,e.LeafletTileLayerDefinition=h,Object.defineProperty(e,"__esModule",{value:!0})});